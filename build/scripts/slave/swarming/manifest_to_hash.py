#!/usr/bin/env python
# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Prints the list of all the .isolated files built and their hash."""

import glob
import hashlib
import json
import optparse
import os
import re
import sys

from slave import build_directory


def hash_file(filepath):
  """Calculates the hash of a file without reading it all in memory at once."""
  digest = hashlib.sha1()
  with open(filepath, 'rb') as f:
    while True:
      chunk = f.read(1024*1024)
      if not chunk:
        break
      digest.update(chunk)
  return digest.hexdigest()


def main():
  parser = optparse.OptionParser(usage='%prog [options]')
  parser.add_option('--target', help='Release or Debug')
  parser.add_option('--output-json',
                    help='File to dump JSON results into. '
                    'If unspecified, writes to stdout.')
  options, _ = parser.parse_args()

  assert options.target
  build_dir = build_directory.GetBuildOutputDirectory()
  outdir = os.path.join(build_dir, options.target)

  result = {}

  # Get the file hash values and output the pair.
  for filepath in sorted(glob.glob(os.path.join(outdir, '*.isolated'))):
    test_name = os.path.splitext(os.path.basename(filepath))[0]
    if re.match(r'^.+?\.\d$', test_name):
      # It's a split .isolated file, e.g. foo.0.isolated. Ignore these.
      continue

    sha1_hash = hash_file(filepath)
    os.remove(filepath)
    if not options.output_json:
      print('%s %s' % (test_name, sha1_hash))
      # TODO(csharp): Remove both the message and the deletion once the isolate
      # tracked dependencies are inputs for the isolated files.
      print('Deleted %s to ensure it is regenerated by the next build.' %
            filepath)
    else:
      result[test_name] = sha1_hash

  if options.output_json:
    with open(options.output_json, 'wb') as f:
      json.dump(result, f)


if __name__ == '__main__':
  sys.exit(main())
